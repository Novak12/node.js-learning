# cluster，你真的整明白了吗
我们在回顾以下cluster的基本使用
```javascript
const cluster = require('cluster');
const http = require('http');
const numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`工作进程 ${worker.process.pid} 已退出`);
  });
} else {
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);
}
```
上面的代码就简单的将cluster模块加入到了node.js项目中。但是仔细分析一下这段代码你可能会产生这些疑问：主进程仅仅fork出了子进程，并没有创建httpserver，说好的主进程接收请求分发给子进程呢？每一个子进程都创建了一个httpserver，并侦听同一个端口？是这样的吗？局面好像很尴尬。如果仅仅知道上面的这段代码，似乎无法解决我们的疑惑。那就到源代码中去瞧瞧.
# cluster.js
```javascript
'use strict';

const childOrMaster = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'master';
module.exports = require(`internal/cluster/${childOrMaster}`);
```
上面的三行代码就是cluster.js的全部内容，可以看出，子进程和主进程的区分是通过‘NODE_UNIQUE_ID’来判断的。我们分析cluster.fork方法可以发现，在createworkprocess中都会对NODE_UNIQUE_ID进行赋值，而master进程中是没有NODE_UNIQUE_ID的。所以再demo程序中可以分别在主进程和子进程中执行不同的内容。因此主进程执行完后，就仅仅fork出了子进程。
# 主进程httpserver
主进程执行完毕后，子进程开始执行响应的代码，子进程首先创建httpserver，然后监听端口号，而正是这个listen方法，暗藏着问题的关键。http模块http.server继承了net模块的net.server，那我们就来看看net.js中的Server.prototype.listen干了哪些事。
